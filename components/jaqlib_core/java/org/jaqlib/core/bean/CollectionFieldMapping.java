package org.jaqlib.core.bean;

import java.util.Collection;

/**
 * Represents a field that has the type (or subtype of) {@link Collection}. This
 * special mapping is needed because collection fields have also an element type
 * to which data should be mapped.
 * 
 * @author Werner Fragner
 * 
 * @param <T> the type of the collection field (e.g. List<Account>).
 */
public class CollectionFieldMapping<T> extends FieldMapping<T>
{

  private final BeanMapping<?> elementMapping;

  private boolean userDefinedSingular = false;
  private boolean pluralSourceName = true;
  private String singularSourceName = null;


  /**
   * Constructs a new collection field mapping by using the given name as source
   * and target name.
   * 
   * @param fieldName the Java bean field name.
   * @param fieldType the type of the Java bean field.
   * @param elementMapping the mapping definition for the elements of the
   *          collection.
   */
  public CollectionFieldMapping(String fieldName, Class<?> fieldType,
      BeanMapping<?> elementMapping)
  {
    super(fieldName, fieldType);
    this.elementMapping = elementMapping;
  }


  /**
   * Gets the mapping definition for the elements of the collection.
   * 
   * @return see description.
   */
  public BeanMapping<?> getElementMapping()
  {
    return elementMapping;
  }


  /**
   * <p>
   * Sets the singular name of the elements in the collection at the source.
   * E.g. if the collection is named 'transactions' at the source the element
   * names could be 'transaction'.
   * </p>
   * <p>
   * If no singular name is given then it is generated by assuming that the
   * collection name ends with a 's' or 'List'. This part is stripped from the
   * source name in order to generate the singular name.
   * </p>
   * 
   * @param name the singular source name that should be used to find the
   *          collection elements at the source.
   */
  public void setSingularSourceName(String name)
  {
    this.pluralSourceName = true;
    this.singularSourceName = name;

    this.userDefinedSingular = true;
  }


  /**
   * Checks if this collection has a plural name at the <b>source</b>. If the
   * user has defined a singular source name (see
   * {@link #setSingularSourceName(String)}) then it is assumed that the
   * <tt>sourceName</tt> contains a plural name. If not the source name is
   * checked if it ends with 's' or 'List'. In that case it is considered as
   * plural.
   * 
   * @return see description.
   */
  public boolean hasPluralName()
  {
    if (this.userDefinedSingular)
    {
      return this.pluralSourceName;
    }

    return getSourceName().endsWith("s") || getSourceName().endsWith("List");
  }


  /**
   * Gets the singular name of the elements in the collection at the source. If
   * the user has specified a singular name using
   * {@link #setSingularSourceName(String)} then this value is returned.
   * Otherwise a singular name is generated by stripping a trailing 's' or
   * 'List' from the source name of this field.
   * 
   * @return see description.
   */
  public String getSingularName()
  {
    if (this.userDefinedSingular)
    {
      return this.singularSourceName;
    }

    String name = getSourceName();

    if (name.endsWith("s"))
    {
      return name.substring(0, name.length() - 1);
    }
    else if (name.endsWith("List"))
    {
      return name.substring(0, name.length() - 4);
    }
    return name;
  }

}
